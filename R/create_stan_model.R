# WARNING - Generated by {fusen} from dev/flat_mbm_function.Rmd: do not edit by hand

#' @title create_stan_model
#' @description This R function creates Stan models based on the specified formula, the data frame of weights, and family distribution. 
#' @param formula, which specifies the model structure
#' @param  df_weights is a data frame of weights (a vector of weights converted into a data frame)
#' @param family: distribution family of the model.
#' @return model: the output is the compiled model.
#' @export
#' @examples
#' ## Build models.
#' #choose some weights to test the model on:
#' weights <- c(2,1,0,4,2,2,2,1,1,3,8) #can be anything, just need the variable names
#'
#' #add arbitrary labels (this is used just to build the model)
#' weight_labels <- as.factor(rep(c(0,1),length(weights))) 
#'
#' #build and compile all base models (this saves time when running the models!)
#' normal_model_base <-create_stan_model('weights ~ 1', data.frame(weights=weights),"normal")
#' skewnormal_model_base <- create_stan_model('weights ~ 1', data.frame(weights=weights), "skew_normal")
#' poisson_model_base <- suppressMessages(create_stan_model('weights ~ 1', data.frame(weights=weights), "poisson"))
#' poisson_model_label <- suppressMessages(create_stan_model('weights ~ 1 + label', data.frame(weights=weights, label=weight_labels), "poisson"))
#'

create_stan_model <- function(formula,df_weights, family){
  
  
  #for normal and skew normal add priors
  if(family=="normal" ) {
    
    #use brm to create the stan code and data for the model
    scode <- brms::make_stancode(formula, data=df_weights, family = family , prior =c(brms::prior ('normal(0,1)', class='Intercept',lb = 0), brms::prior('normal(0,1)', class='sigma')))
    
  } else if (family == "skew_normal") {
    
    my_priors<-brms::get_prior( formula , data=df_weights, family = "skew_normal" )
    
    #use brm to create the stan code and data for the model
    scode <- brms::make_stancode(formula, data=df_weights, family = family, prior =my_priors )
    
  } else if (family == "poisson") {
    
    if (grepl("label", formula)) {
      
      df_weights$label <- as.factor(df_weights$label)
      my_priors <- brms::get_prior(brms::bf(weights ~ 1 + label), data = df_weights, family = "poisson")
      my_priors[1, 1] <- "normal(0,1)"
      # Use brm to create the stan code and data for the model
      scode <- brms::make_stancode(formula, data=df_weights, family = family, prior = my_priors)
    } else {
      # Get default priors from brms
      my_priors <- brms::get_prior(formula, data = df_weights, family = "poisson")
      # Use brm to create the stan code and data for the model
      scode <- brms::make_stancode(formula, data=df_weights, family = family, prior = my_priors)
    }
    
  } else {
    
    print('unsupported model family used')
  }
  
  #create the stan model
  model <- rstan::stan_model(model_code=scode)
  
  return(model)
}


#' @title fit_stan_model
#' @description This function fits the a Stan model to the given data, using the rstan package
#' @param model which corresponds to the base model (normal_model_base, skewnormal_model_base, poisson_model_base, poisson_model_label)
#' @param formula specifies the model structure.
#' @param df_weights is a vector of weights 
#' @param family is the distribution family of the model
#' @return fit: the output is the fitted brms model.
#' @export
#' @examples
#' ## Build models.
#' #choose some weights to test the model on:
#' weights <- c(2,1,0,4,2,2,2,1,1,3,8) #can be anything, just need the variable names
#'
#' #add arbitrary labels (this is used just to build the model)
#' weight_labels <- as.factor(rep(c(0,1),length(weights))) 
#'
#' #build and compile all base models (this saves time when running the models!)
#' normal_model_base <-create_stan_model('weights ~ 1', data.frame(weights=weights),"normal")
#'
#' model.output<-fit_stan_model(normal_model_base,'weights ~ 1', data.frame(weights=weights), family="normal")

fit_stan_model <- function(model, formula, df_weights, family){
  
  #get the data into rstan format
  sdata <- brms::make_standata(formula, df_weights )
  
  #fit the model to the data
  stanfit <- suppressWarnings(rstan::sampling(object = model, data = sdata, refresh = 0, chains=1))
  
  # feed the Stan model back into a brms model
  fit <- brms::brm(formula, df_weights, empty = TRUE, family = family)
  fit$fit <- stanfit
  fit <- brms::rename_pars(fit)
  
  return(fit)
}


#' @title model_based_extraction
#' @description This function identifies and classifies strong ties in a network based on weight data.
#' @param weights: a vector of weights to be analyzed
#' @param sd_diff is the standard deviation difference threshold for identifying skewness
#' @param min_diff is the minimum difference threshold for model comparison.
#' @param model_backend: Specifies the backend used for fitting models (e.g., "rstan")
#' @param normal_model_base is the base model for fitting normal distribution
#' @param skewnormal_model_base is the base model for fitting skew-normal distribution
#' @param poisson_model_base is the base model for fitting Poisson distribution
#' @param poisson_model_label is the base model for fitting Poisson distribution
#' @return The output is a data frame with two columns: "weight" and "strong", indicating whether each weight is classified as a strong tie.
#' @export
#' 
#' 
#' @examples
#' devtools::load_all("/Users/chloevillette/Desktop/strongTies")
#'
#' library(dplyr)
#' library(brms)
#' library(rstan)
#'
#' # Create a data set
#' simulated.df<-netTS::sim.events.data(50, 100,20)
#' simulated.data<-simulated.df$beha
#' simulated.data<-simulated.data[,c(1:2)]
#'
#' # Isolate a certain individual (#12).
#' subset.id <- simulated.data %>% dplyr::filter (from =="12")
#'
#' # Create an edgelist
#' edgelist.id <- netTS::create.an.edgeList(subset.id)
#'
#' # Run the function 
#' if(nrow(edgelist.id)>10){
#'   
#'   strong.ties <-model_based_extraction(edgelist.id$weight, sd_diff = 0, min_diff=3, model_backend="rstan")
#'   
#' }else{
#'   
#'   strong.ties <- model_based_extraction(edgelist.id$weight, sd_diff = 0, min_diff=1, model_backend="rstan")
#' }
#'
#' # Re-attribute partners to the corresponding weights
#' edgelist.id <- edgelist.id[order(edgelist.id$weight),] 
#' strong.ties <-cbind(strong.ties,edgelist.id[,c("from", "to")])
library(dplyr)
library(brms)
library(rstan)

model_based_extraction <- function(weights, sd_diff = 0 , min_diff=2 , model_backend="rstan"){
  
  # Call preload_models to load the preloaded models
  model.list <- preload_models()
  
  #sort weights
  weights <- sort(weights)
  
  #store outputs
  df_models <- data.frame()
  
  #start off (model has to beat this)
  max_density = -999999
  
  #### Step 1: check for evidence of skewness
  
  #fit a model with a normal distribution
  fit.normal <- fit_stan_model(model.list[[1]],'weights ~ 1', data.frame(weights=weights), family="normal")
  
  #fit a model with a skew normal distribution
  fit.skew <- fit_stan_model (model.list[[2]],'weights ~ 1', data.frame(weights=weights), family="skew_normal")
  
  #compare models using leave-one-out cross validation
  loo_res<- suppressWarnings(loo::loo_compare(loo(fit.skew),loo(fit.normal) ) )
  
  #### Step 2: If there is skewness, try to classify which weights are outside expectation using the normal distribution
  
  #check to see if there is sufficient evidence for 'skew': if the (top model is the skew model) & (lower bound of the difference between models if greater than 0) & (the min difference is above a threshold: min_diff) then there is evidence of a skew
  if(rownames(loo_res)[1]=="fit.skew" & (loo_res[2,1] + sd_diff*loo_res[2,2] < 0 ) & (loo_res[2,1]<=(-min_diff))  ){  #   min_diff makes it more conservative...
    
    #loop through the data and try assigning different strong tie options (#start with largest weight, assign it as a strong tie, then move on and assign the first two weights as strong ties, ... etc)
    for (s in 0:round(length(weights)/2) ){ #only look at the highest half of the weights
      
      #for the first model no weights are given strong tie status
      if(s==0){
        
        #all weights are not strong ties
        weight_labels <- as.factor(rep(0,length(weights)))
        
        #fit a normal distribution
        fit.skew2 <-fit_stan_model(model.list[[3]],'weights ~ 1', data.frame(weights=weights), family="poisson")
        
        loo_labels = suppressWarnings(loo(fit.skew2))
        
        #for all other models assign weights as either strong ties or not
      } else {
        
        #what weights to set as strong ties
        l=length(weights)-s #top weight
        
        weight_labels<-c(rep(0,l),seq(1,s,by=1) )
        
        #fit a skewed normal
        fit.skew2 <- fit_stan_model(model.list[[4]],'weights ~ 1 + label', data.frame(weights=weights, label=as.factor(weight_labels) ), family="poisson")
        
        loo_labels = suppressWarnings(loo(fit.skew2))
        
      }
      
      #extract the loo
      loo_labels = suppressWarnings(loo(fit.skew2))
      
      #if the model beats the last model save it as the best
      if(loo_labels$estimates[1,1]>max_density & loo_labels$estimates[1,1]-max_density > min_diff ){ # min_diff makes the choice more conservative: 
        
        fit_save = fit.skew2
        label_save = as.numeric(as.character(weight_labels))
        max_density=loo_labels$estimates[1,1]
        
        #save all the results
        df_models <-  dplyr::bind_rows(df_models, data.frame(strongTies = s, elpd = loo_labels$estimates[1,1], looic = loo_labels$estimates[3,1]))
        
      } else {
        df_models <-  dplyr::bind_rows(df_models, data.frame(strongTies = s, elpd = loo_labels$estimates[1,1], looic = loo_labels$estimates[3,1]))
        break
      }
    }
    
    return( data.frame(weight=weights, strong = as.numeric(label_save>0)))
    
  } else {
    
    return(data.frame(weight=weights, strong = rep(0, length(weights))))
    
  }
}


#' Preload base models for model-based extraction
#' @title preload_models
#' @description This R function creates preloaded base models which will make the classification of strong ties faster. 
#' @export
preload_models <- function() {
  
  weights<-c(7,7,7,7,7,7,7,7)
  weight_labels <- as.factor(rep(c(0,1),length(weights))) 
  # Build and compile all base models
  normal_model_base <<- create_stan_model('weights ~ 1', data.frame(weights = weights), "normal")
  skewnormal_model_base <<- create_stan_model('weights ~ 1', data.frame(weights = weights), "skew_normal")
  poisson_model_base <<- suppressMessages(create_stan_model('weights ~ 1', data.frame(weights = weights), "poisson"))
  poisson_model_label <<- suppressMessages(create_stan_model('weights ~ 1 + label', data.frame(weights = weights, label = weight_labels), "poisson"))
  
  return(list(normal_model_base,skewnormal_model_base,poisson_model_base,poisson_model_label))
  
}
